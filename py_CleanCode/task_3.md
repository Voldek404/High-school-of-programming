# Task 2 

## 7.1 корректные наименования для нулевых переменных

1) covered - is_covered
// Переменная не подразумевала однозначно true or false

2) flag - is_recursive_call
// переменная flag должна была управлять рекурсивным вызовом. True - производство рекурсивного вызова Задача из py_1 на работу с каталогами

3) result - is_match
// переменная из задачи про танковый раш из 28 задач. Сама по себе переменная result абсолютно ни о чем не говорит. Полезно возвращаться к своему коду спустя время

4) rot_flag - is_rot 
// пример из чужого кода 

5) flag - is_all_positive
// пример из чужого кода, где флаг использовался для цикла while, функционирующего пока числа положительные




## 7.2 стандартные для булевых переменных наименования

1) is_match - success
// условное совпадение/попадание явно можно заменить стандартным термином

2) result - found
// из задачи про белых ходоков, где необходимо было вывести факт обнаружения



## 7.3 - наглядное обозначение переменных- счетчиков

1) for char in str_obj
// перебор символов в объекте типа строки

2) for index in list_obj
// случай, когда переменная счетчика используется вне итераций

3) for _ in range
// для отображения "безразличия" к переменной счетчика ( в случае нескольких циклов)



## 7.4 пары слов - антонимы

1) cumulative_sum_straight - cumulative_sum_reversed
// прямая (оригинальная) кумулятивная сумма и обратная

2) left_edge - right_edge
// крайний левый и крайний правый пределы

3) p_value_forward - p_value_backward
// метрики для определения "случайности" Битовой последовательности



## 7.5 Временные переменные
1) initial_demand = total_capacity\
queue = deque()\
for i in range(100):  # 100 шагов (например, для 100 минут или секунд)\
    demand_random_changer = np.random.choice(np.arange(0, 1.0, 0.05))\
    demand = demand_random_changer *  initial_demand\
//Временная переменная initial_demand создавалась для отделения процесса от общей мощности \total_capacity, однако после проведенного анализа стало ясно, что переменная целиком лишняя

2) temp - temporary_list, temporary_string
// чаще всего временные переменные в моем коде именовались просто как temp, что было не совсем наглядно

3) 
training_space = []
for i in range(1, N + 1):\
    a1 = []\
    for j in range(1, M + 1):\
        a1.append(0)\
    training_space.append(a1)\
// еще одна лишняя временная переменная а1. Можно обойтись без нее
training_space = [] \
for i in range(1, N + 1):\
    training_space.append([0] * M)

